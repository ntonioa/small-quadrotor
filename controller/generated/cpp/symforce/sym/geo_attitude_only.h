// -----------------------------------------------------------------------------
// This file was autogenerated by symforce from template:
//     function/FUNCTION.h.jinja
// Do NOT modify by hand.
// -----------------------------------------------------------------------------

#pragma once

#include <Eigen/Core>

namespace sym {

/**
 * This function was autogenerated from a symbolic function. Do not modify by hand.
 *
 * Symbolic function: <lambda>
 *
 * Args:
 *     q: Quaternion
 *     qd: Quaternion
 *     omega: Matrix31
 *     kR: Matrix31
 *     kW: Matrix31
 *     J: Matrix33
 *
 * Outputs:
 *     tau: Matrix31
 */
template <typename Scalar>
void GeoAttitudeOnly(const sym::Quaternion<Scalar>& q, const sym::Quaternion<Scalar>& qd,
                     const Eigen::Matrix<Scalar, 3, 1>& omega,
                     const Eigen::Matrix<Scalar, 3, 1>& kR, const Eigen::Matrix<Scalar, 3, 1>& kW,
                     const Eigen::Matrix<Scalar, 3, 3>& J,
                     Eigen::Matrix<Scalar, 3, 1>* const tau = nullptr) {
  // Total ops: 82

  // Input arrays
  const Eigen::Matrix<Scalar, 4, 1>& _q = q.Data();
  const Eigen::Matrix<Scalar, 4, 1>& _qd = qd.Data();

  // Intermediate terms (10)
  const Scalar _tmp0 = Scalar(1.0) / (std::pow(_qd[0], Scalar(2)) + std::pow(_qd[1], Scalar(2)) +
                                      std::pow(_qd[2], Scalar(2)) + std::pow(_qd[3], Scalar(2)));
  const Scalar _tmp1 = _q[0] * _tmp0;
  const Scalar _tmp2 = _q[3] * _tmp0;
  const Scalar _tmp3 = _qd[1] * _tmp0;
  const Scalar _tmp4 = _q[1] * _tmp0;
  const Scalar _tmp5 = _q[2] * _tmp0;
  const Scalar _tmp6 =
      2 * (((_q[1] * _tmp3 + _qd[0] * _tmp1 + _qd[2] * _tmp5 + _qd[3] * _tmp2) > 0) -
           ((_q[1] * _tmp3 + _qd[0] * _tmp1 + _qd[2] * _tmp5 + _qd[3] * _tmp2) < 0));
  const Scalar _tmp7 = J(2, 0) * omega(0, 0) + J(2, 1) * omega(1, 0) + J(2, 2) * omega(2, 0);
  const Scalar _tmp8 = J(1, 0) * omega(0, 0) + J(1, 1) * omega(1, 0) + J(1, 2) * omega(2, 0);
  const Scalar _tmp9 = J(0, 0) * omega(0, 0) + J(0, 1) * omega(1, 0) + J(0, 2) * omega(2, 0);

  // Output terms (1)
  if (tau != nullptr) {
    Eigen::Matrix<Scalar, 3, 1>& _tau = (*tau);

    _tau(0, 0) =
        -_tmp6 * kR(0, 0) * (-_q[2] * _tmp3 - _qd[0] * _tmp2 + _qd[2] * _tmp4 + _qd[3] * _tmp1) +
        _tmp7 * omega(1, 0) - _tmp8 * omega(2, 0) - kW(0, 0) * omega(0, 0);
    _tau(1, 0) =
        -_tmp6 * kR(1, 0) * (-_q[3] * _tmp3 + _qd[0] * _tmp5 - _qd[2] * _tmp1 + _qd[3] * _tmp4) -
        _tmp7 * omega(0, 0) + _tmp9 * omega(2, 0) - kW(1, 0) * omega(1, 0);
    _tau(2, 0) =
        -_tmp6 * kR(2, 0) * (_q[0] * _tmp3 - _qd[0] * _tmp4 - _qd[2] * _tmp2 + _qd[3] * _tmp5) +
        _tmp8 * omega(0, 0) - _tmp9 * omega(1, 0) - kW(2, 0) * omega(2, 0);
  }
}  // NOLINT(readability/fn_size)

// NOLINTNEXTLINE(readability/fn_size)
}  // namespace sym
