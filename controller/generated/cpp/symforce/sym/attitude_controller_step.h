// -----------------------------------------------------------------------------
// This file was autogenerated by symforce from template:
//     function/FUNCTION.h.jinja
// Do NOT modify by hand.
// -----------------------------------------------------------------------------

#pragma once

#include <Eigen/Core>

namespace sym {

/**
 * This function was autogenerated from a symbolic function. Do not modify by hand.
 *
 * Symbolic function: <lambda>
 *
 * Args:
 *     q: Quaternion
 *     omega: Matrix31
 *     phi: Scalar
 *     theta: Scalar
 *     psi: Scalar
 *     kR: Matrix31
 *     kW: Matrix31
 *     J: Matrix33
 *     m: Scalar
 *     g: Scalar
 *     thr: Scalar
 *
 * Outputs:
 *     y: Matrix41
 */
template <typename Scalar>
void AttitudeControllerStep(const sym::Quaternion<Scalar>& q,
                            const Eigen::Matrix<Scalar, 3, 1>& omega, const Scalar phi,
                            const Scalar theta, const Scalar psi,
                            const Eigen::Matrix<Scalar, 3, 1>& kR,
                            const Eigen::Matrix<Scalar, 3, 1>& kW,
                            const Eigen::Matrix<Scalar, 3, 3>& J, const Scalar m, const Scalar g,
                            const Scalar thr, Eigen::Matrix<Scalar, 4, 1>* const y = nullptr) {
  // Total ops: 108

  // Input arrays
  const Eigen::Matrix<Scalar, 4, 1>& _q = q.Data();

  // Intermediate terms (26)
  const Scalar _tmp0 = J(2, 0) * omega(0, 0) + J(2, 1) * omega(1, 0) + J(2, 2) * omega(2, 0);
  const Scalar _tmp1 = J(1, 0) * omega(0, 0) + J(1, 1) * omega(1, 0) + J(1, 2) * omega(2, 0);
  const Scalar _tmp2 = (Scalar(1) / Scalar(2)) * theta;
  const Scalar _tmp3 = std::sin(_tmp2);
  const Scalar _tmp4 = (Scalar(1) / Scalar(2)) * psi;
  const Scalar _tmp5 = std::cos(_tmp4);
  const Scalar _tmp6 = (Scalar(1) / Scalar(2)) * phi;
  const Scalar _tmp7 = std::cos(_tmp6);
  const Scalar _tmp8 = _tmp5 * _tmp7;
  const Scalar _tmp9 = std::cos(_tmp2);
  const Scalar _tmp10 = std::sin(_tmp6);
  const Scalar _tmp11 = std::sin(_tmp4);
  const Scalar _tmp12 = _tmp10 * _tmp11;
  const Scalar _tmp13 = _tmp12 * _tmp9 + _tmp3 * _tmp8;
  const Scalar _tmp14 = _tmp12 * _tmp3 + _tmp8 * _tmp9;
  const Scalar _tmp15 = _tmp10 * _tmp5;
  const Scalar _tmp16 = _tmp11 * _tmp7;
  const Scalar _tmp17 = -_tmp15 * _tmp3 + _tmp16 * _tmp9;
  const Scalar _tmp18 = _tmp15 * _tmp9 - _tmp16 * _tmp3;
  const Scalar _tmp19 = Scalar(1.0) / (std::pow(_tmp13, Scalar(2)) + std::pow(_tmp14, Scalar(2)) +
                                       std::pow(_tmp17, Scalar(2)) + std::pow(_tmp18, Scalar(2)));
  const Scalar _tmp20 = _tmp18 * _tmp19;
  const Scalar _tmp21 = _tmp17 * _tmp19;
  const Scalar _tmp22 = _tmp14 * _tmp19;
  const Scalar _tmp23 = _tmp13 * _tmp19;
  const Scalar _tmp24 =
      2 * (((_q[0] * _tmp22 + _q[1] * _tmp20 + _q[2] * _tmp23 + _q[3] * _tmp21) > 0) -
           ((_q[0] * _tmp22 + _q[1] * _tmp20 + _q[2] * _tmp23 + _q[3] * _tmp21) < 0));
  const Scalar _tmp25 = J(0, 0) * omega(0, 0) + J(0, 1) * omega(1, 0) + J(0, 2) * omega(2, 0);

  // Output terms (1)
  if (y != nullptr) {
    Eigen::Matrix<Scalar, 4, 1>& _y = (*y);

    _y(0, 0) =
        _tmp0 * omega(1, 0) - _tmp1 * omega(2, 0) -
        _tmp24 * kR(0, 0) * (_q[0] * _tmp21 + _q[1] * _tmp23 - _q[2] * _tmp20 - _q[3] * _tmp22) -
        kW(0, 0) * omega(0, 0);
    _y(1, 0) =
        -_tmp0 * omega(0, 0) -
        _tmp24 * kR(1, 0) * (-_q[0] * _tmp23 + _q[1] * _tmp21 + _q[2] * _tmp22 - _q[3] * _tmp20) +
        _tmp25 * omega(2, 0) - kW(1, 0) * omega(1, 0);
    _y(2, 0) =
        _tmp1 * omega(0, 0) -
        _tmp24 * kR(2, 0) * (_q[0] * _tmp20 - _q[1] * _tmp22 + _q[2] * _tmp21 - _q[3] * _tmp23) -
        _tmp25 * omega(1, 0) - kW(2, 0) * omega(2, 0);
    _y(3, 0) = g * m * thr;
  }
}  // NOLINT(readability/fn_size)

// NOLINTNEXTLINE(readability/fn_size)
}  // namespace sym
